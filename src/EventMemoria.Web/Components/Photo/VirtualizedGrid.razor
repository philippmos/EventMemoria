@using EventMemoria.Web.Common.Constants
@using EventMemoria.Web.Common.Settings
@using EventMemoria.Web.Services.Interfaces
@using Microsoft.Extensions.Options

@implements IAsyncDisposable

<MudContainer MaxWidth="MaxWidth.False" Class="pa-0">
    @if (_isLoading)
    {
        <MudStack Spacing="3" Class="pa-4">
            <MudProgressLinear Color="Color.Primary" Indeterminate="true" />
            <MudText Typo="Typo.body1" Align="Align.Center">Lade Medien...</MudText>
        </MudStack>
    }
    else if (_allPhotos.Any())
    {
        <MudStack Spacing="2" Class="pa-2">
            @if (ShowGridControls)
            {
                <GridControlsComponent PhotosPerRow="@PhotosPerRow"
                                       OnPhotosPerRowChanged="@SetPhotosPerRowAsync" />
            }

            <div class="photo-grid">
                <MudVirtualize
						Items="@_photoRows"
						Context="row"
						ItemSize="@GetRowHeight()"
						OverscanCount="@ApplicationConstants.Pagination.VirtualizationOverscanCount">
                    <div class="photo-grid__row">
                        @foreach (var photo in row)
                        {
                            <CardComponent Photo="@photo"
                                                PhotosPerRow="@PhotosPerRow"
                                                IsPhotoLoaded="@_loadedPhotos.Contains(photo.Id)"
                                                OnPhotoClicked="@OnPhotoClickedAsync"
                                                OnPhotoLoaded="@OnPhotoLoadedAsync" />
                        }
                    </div>
                </MudVirtualize>

                @if (_currentPage < _totalPages)
                {
                    <div class="photo-grid__load-trigger" @ref="_loadTriggerElement">
                        @if (_isLoadingMore)
                        {
                            <MudStack Spacing="2" Justify="Justify.Center" AlignItems="AlignItems.Center" Class="pa-4">
                                <MudProgressCircular Color="Color.Primary" Indeterminate="true" Size="Size.Small" />
                                <MudText Typo="Typo.caption">Lade weitere Medien...</MudText>
                            </MudStack>
                        }
                        else
                        {
                            <MudButton Variant="Variant.Text"
                                     Color="Color.Primary"
                                     OnClick="@LoadNextPageIfAvailableAsync"
                                     Class="ma-2">
                                Mehr Medien laden (@(_totalPages - _currentPage) Seiten Ã¼brig)
                            </MudButton>
                        }
                    </div>
                }
            </div>
        </MudStack>
    }
    else
    {
        <MudAlert Severity="Severity.Info" Class="ma-4">
            Keine Medien vorhanden. Starte mit dem Hochladen!
        </MudAlert>
    }
</MudContainer>



@code {
    [Parameter] public EventCallback<List<Photo>> OnPhotosLoaded { get; set; }
    [Parameter] public string? GalleryFolderName { get; set; }
    [Parameter] public bool ShowGridControls { get; set; }

	[Inject] private IOptions<PhotoOptions> PhotoOptions { get; set; } = null!;
	[Inject] private IPhotoGridService PhotoGridService { get; set; } = null!;
	[Inject] private IStorageService StorageService { get; set; } = null!;
	[Inject] private IDialogService DialogService { get; set; } = null!;
	[Inject] private ISnackbar Snackbar { get; set; } = null!;
	[Inject] private IJSRuntime JsRuntime { get; set; } = null!;
	[Inject] private ILogger<VirtualizedGrid> Logger {get; set;} = null!;

	private int PhotosPerRow { get; set; }
	private List<Photo> _allPhotos = [];
	private List<List<Photo>> _photoRows = [];
	private readonly HashSet<string> _loadedPhotos = [];
	private bool _isLoading = true;
    private bool _isLoadingMore;
	private int _currentPage = 1;
    private int _totalPages;
	private readonly int _pageSize = ApplicationConstants.Pagination.DefaultPageSize;
	private ElementReference _loadTriggerElement;
	private DotNetObjectReference<VirtualizedGrid>? _dotNetObjectRef;

	protected override void OnInitialized()
	{
		PhotosPerRow = PhotoOptions.Value.DefaultPhotosPerRow;
		_dotNetObjectRef = DotNetObjectReference.Create(this);
	}

	protected override async Task OnAfterRenderAsync(bool firstRender)
	{
		if (firstRender)
		{
			await LoadPhotosPageAsync(1, true);
		}
		else if (_currentPage < _totalPages
			&& _loadTriggerElement.Context != null)
		{
			await ObserveLoadTriggerAsync();
		}
	}

	private async Task ObserveLoadTriggerAsync()
	{
		try
		{
			await JsRuntime.InvokeVoidAsync("IntersectionObserverManager.observe", _loadTriggerElement, _dotNetObjectRef);
		}
		catch (Exception ex)
		{
			Logger.LogError(ex, "Error setting up intersection observer.");
		}
	}

	[JSInvokable]
	public async Task OnLoadTriggerVisible()
	{
		await LoadNextPageIfAvailableAsync();
	}

	private async Task LoadPhotosPageAsync(int page, bool isInitialLoad = false)
	{
		try
		{
			if (isInitialLoad)
			{
				_isLoading = true;
			}
			else
			{
				_isLoadingMore = true;
			}
			StateHasChanged();

            var result = await StorageService.GetPhotosPagedAsync(page, _pageSize, GalleryFolderName);

			if (isInitialLoad)
			{
				_allPhotos = result.Items;
			}
			else
			{
				_allPhotos.AddRange(result.Items);
			}

			_currentPage = result.CurrentPage;
			_totalPages = result.TotalPages;

			CreatePhotoRows();

			if (OnPhotosLoaded.HasDelegate)
			{
				await OnPhotosLoaded.InvokeAsync(_allPhotos);
			}

		}
		catch (Exception ex)
		{
			Snackbar.Add($"Fehler beim Laden der Medien: {ex.Message}", Severity.Error);
		}
		finally
		{
			_isLoading = false;
			_isLoadingMore = false;
			StateHasChanged();
		}
	}

	private async Task LoadNextPageIfAvailableAsync()
	{
		if (_isLoadingMore || _currentPage >= _totalPages)
		{
			return;
		}

		await LoadPhotosPageAsync(_currentPage + 1);
	}

	private void CreatePhotoRows()
	{
		_photoRows = PhotoGridService.CreatePhotoRows(_allPhotos, PhotosPerRow);
	}

	private async Task SetPhotosPerRowAsync(int count)
	{
		if (!PhotoGridService.IsValidPhotosPerRow(count) || PhotosPerRow == count)
		{
			return;
		}

		PhotosPerRow = count;
		CreatePhotoRows();
		await InvokeAsync(StateHasChanged);
	}

	private int GetRowHeight() => PhotoGridService.GetRowHeight(PhotosPerRow);

	private async Task OnPhotoLoadedAsync(string photoId)
	{
		if (_loadedPhotos.Add(photoId))
		{
            await InvokeAsync(StateHasChanged);
		}
	}

	private async Task OnPhotoClickedAsync(Photo photo)
	{
		var photoIndex = _allPhotos.FindIndex(p => p.Id == photo.Id);
		if (photoIndex >= 0)
		{
			await OpenGalleryAsync(photoIndex);
		}
	}

	private async Task OpenGalleryAsync(int initialIndex)
	{
		if (!_allPhotos.Any() || initialIndex < 0)
		{
			return;
		}

        var pageSize = ApplicationConstants.Pagination.MaxPageSize;
        var currentPage = (initialIndex / pageSize) + 1;
        var startIndex = (currentPage - 1) * pageSize;
        var galleryPhotos = _allPhotos.Skip(startIndex).Take(pageSize).ToList();
        var adjustedIndex = Math.Max(0, initialIndex - startIndex);

        var parameters = new DialogParameters<GalleryDialog>
        {
            { x => x.Photos, galleryPhotos },
            { x => x.InitialIndex, adjustedIndex },
            { x => x.CurrentPage, currentPage },
            { x => x.TotalPages, (int)Math.Ceiling((double)_allPhotos.Count / pageSize) }
        };

        var options = new DialogOptions
        {
            MaxWidth = MaxWidth.ExtraExtraLarge,
            FullWidth = true,
            CloseOnEscapeKey = true,
            CloseButton = true,
            FullScreen = true
        };

        await DialogService.ShowAsync<GalleryDialog>("Fotogalerie", parameters, options);
    }

    public async Task RefreshPhotosAsync()
    {
        _loadedPhotos.Clear();
        _currentPage = 1;
        _totalPages = 0;
        await LoadPhotosPageAsync(1, true);
    }

    public async ValueTask DisposeAsync()
    {
        _dotNetObjectRef?.Dispose();

        try
        {
            await JsRuntime.InvokeVoidAsync("IntersectionObserverManager.dispose");
        }
        catch (Exception)
        {
            // Ignore disposal errors
        }
    }
}
