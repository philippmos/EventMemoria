@using EventMemoria.Web.Common.Constants
@using EventMemoria.Web.Common.Settings
@using EventMemoria.Web.Models
@using EventMemoria.Web.Services.Interfaces
@using Microsoft.Extensions.Options
@using EventMemoria.Web.Services
@using Microsoft.JSInterop
@implements IAsyncDisposable

<MudContainer MaxWidth="MaxWidth.False" Class="pa-0">
    @if (_isLoading)
    {
        <MudStack Spacing="3" Class="pa-4">
            <MudProgressLinear Color="Color.Primary" Indeterminate="true" />
            <MudText Typo="Typo.body1" Align="Align.Center">Lade Fotos...</MudText>
        </MudStack>
    }
    else if (_allPhotos.Any())
    {
        <MudStack Spacing="2" Class="pa-2">
            <GridControlsComponent PhotosPerRow="@_photosPerRow"
                                        OnPhotosPerRowChanged="@SetPhotosPerRowAsync" />
            
            <div class="photo-grid">
                <MudVirtualize
						Items="@_photoRows"
						Context="row"
						ItemSize="@GetRowHeight()"
						OverscanCount="@ApplicationConstants.Pagination.VirtualizationOverscanCount">
                    <div class="photo-grid__row">
                        @foreach (var photo in row)
                        {
                            <CardComponent Photo="@photo"
                                                PhotosPerRow="@_photosPerRow"
                                                IsPhotoLoaded="@_loadedPhotos.Contains(photo.Id)"
                                                OnPhotoClicked="@OnPhotoClickedAsync"
                                                OnPhotoLoaded="@OnPhotoLoadedAsync" />
                        }
                    </div>
                </MudVirtualize>
                
                @if (_currentPage < _totalPages)
                {
                    <div class="photo-grid__load-trigger" @ref="_loadTriggerElement">
                        @if (_isLoadingMore)
                        {
                            <MudStack Spacing="2" Justify="Justify.Center" AlignItems="AlignItems.Center" Class="pa-4">
                                <MudProgressCircular Color="Color.Primary" Indeterminate="true" Size="Size.Small" />
                                <MudText Typo="Typo.caption">Lade weitere Fotos...</MudText>
                            </MudStack>
                        }
                        else
                        {
                            <MudButton Variant="Variant.Text" 
                                     Color="Color.Primary" 
                                     OnClick="@LoadNextPageIfAvailableAsync"
                                     Class="ma-2">
                                Mehr Fotos laden (@(_totalPages - _currentPage) Seiten Ã¼brig)
                            </MudButton>
                        }
                    </div>
                }
            </div>
        </MudStack>
    }
    else
    {
        <MudAlert Severity="Severity.Info" Class="ma-4">
            Keine Fotos vorhanden. Starte mit dem Hochladen!
        </MudAlert>
    }
</MudContainer>



@code {
	[Parameter] public EventCallback<List<Photo>> OnPhotosLoaded { get; set; }

	[Inject] private IOptions<PhotoOptions> PhotoOptions { get; set; } = default!;
	[Inject] private IPhotoGridService PhotoGridService { get; set; } = default!;
	[Inject] private IStorageService StorageService { get; set; } = default!;
	[Inject] private IDialogService DialogService { get; set; } = default!;
	[Inject] private ISnackbar Snackbar { get; set; } = default!;
	[Inject] private IJSRuntime JSRuntime { get; set; } = default!;
	[Inject] private ILogger<VirtualizedGrid> Logger {get; set;} = default!;

	private int _photosPerRow { get; set; }
	private List<Photo> _allPhotos = new();
	private List<List<Photo>> _photoRows = new();
	private HashSet<string> _loadedPhotos = new();
	private bool _isLoading = true;
	private bool _isLoadingMore = false;
	private int _currentPage = 1;
	private int _totalPages = 0;
	private int _pageSize = ApplicationConstants.Pagination.DefaultPageSize;
	private ElementReference _loadTriggerElement;
	private DotNetObjectReference<VirtualizedGrid>? _dotNetObjectRef;

	protected override void OnInitialized()
	{
		_photosPerRow = PhotoOptions.Value.DefaultPhotosPerRow;
		_dotNetObjectRef = DotNetObjectReference.Create(this);
	}

	protected override async Task OnAfterRenderAsync(bool firstRender)
	{
		if (firstRender)
		{
			await LoadPhotosPageAsync(1, true);
		}
		else if (_currentPage < _totalPages 
			&& _loadTriggerElement.Context != null)
		{
			await ObserveLoadTriggerAsync();
		}
	}

	private async Task ObserveLoadTriggerAsync()
	{
		try
		{
			await JSRuntime.InvokeVoidAsync("IntersectionObserverManager.observe", _loadTriggerElement, _dotNetObjectRef);
		}
		catch (Exception ex)
		{
			Logger.LogError(ex, "Error setting up intersection observer.");
		}
	}

	[JSInvokable]
	public async Task OnLoadTriggerVisible()
	{
		await LoadNextPageIfAvailableAsync();
	}

	private async Task LoadPhotosPageAsync(int page, bool isInitialLoad = false)
	{
		try
		{
			if (isInitialLoad)
			{
				_isLoading = true;
			}
			else
			{
				_isLoadingMore = true;
			}
			StateHasChanged();

			var result = await StorageService.GetPhotosPagedAsync(page, _pageSize);
			
			if (isInitialLoad)
			{
				_allPhotos = result.Items;
			}
			else
			{
				_allPhotos.AddRange(result.Items);
			}

			_currentPage = result.CurrentPage;
			_totalPages = result.TotalPages;

			CreatePhotoRows();

			if (OnPhotosLoaded.HasDelegate)
			{
				await OnPhotosLoaded.InvokeAsync(_allPhotos);
			}

		}
		catch (Exception ex)
		{
			Snackbar.Add($"Fehler beim Laden der Fotos: {ex.Message}", Severity.Error);
		}
		finally
		{
			_isLoading = false;
			_isLoadingMore = false;
			StateHasChanged();
		}
	}

	private async Task LoadNextPageIfAvailableAsync()
	{
		if (_isLoadingMore || _currentPage >= _totalPages)
		{
			return;
		}

		await LoadPhotosPageAsync(_currentPage + 1);
	}

	private void CreatePhotoRows()
	{
		_photoRows = PhotoGridService.CreatePhotoRows(_allPhotos, _photosPerRow);
	}

	private async Task SetPhotosPerRowAsync(int count)
	{
		if (!PhotoGridService.IsValidPhotosPerRow(count) || _photosPerRow == count)
		{
			return;
		}

		_photosPerRow = count;
		CreatePhotoRows();
		await InvokeAsync(StateHasChanged);
	}

	private int GetRowHeight() => PhotoGridService.GetRowHeight(_photosPerRow);

	private async Task OnPhotoLoadedAsync(string photoId)
	{
		if (!_loadedPhotos.Contains(photoId))
		{
			_loadedPhotos.Add(photoId);
			await InvokeAsync(StateHasChanged);
		}
	}

	private async Task OnPhotoClickedAsync(Photo photo)
	{
		var photoIndex = _allPhotos.FindIndex(p => p.Id == photo.Id);
		if (photoIndex >= 0)
		{
			await OpenGalleryAsync(photoIndex);
		}
	}

	private async Task OpenGalleryAsync(int initialIndex)
	{
		if (!_allPhotos.Any() || initialIndex < 0)
		{
			return;
		}

        var pageSize = ApplicationConstants.Pagination.MaxPageSize;
        var currentPage = (initialIndex / pageSize) + 1;
        var startIndex = (currentPage - 1) * pageSize;
        var galleryPhotos = _allPhotos.Skip(startIndex).Take(pageSize).ToList();
        var adjustedIndex = Math.Max(0, initialIndex - startIndex);

        var parameters = new DialogParameters<GalleryDialog>
        {
            { x => x.Photos, galleryPhotos },
            { x => x.InitialIndex, adjustedIndex },
            { x => x.CurrentPage, currentPage },
            { x => x.TotalPages, (int)Math.Ceiling((double)_allPhotos.Count / pageSize) }
        };

        var options = new DialogOptions
        {
            MaxWidth = MaxWidth.ExtraExtraLarge,
            FullWidth = true,
            CloseOnEscapeKey = true,
            CloseButton = true,
            FullScreen = true
        };

        await DialogService.ShowAsync<GalleryDialog>("Fotogalerie", parameters, options);
    }

    public async Task RefreshPhotos()
    {
        _loadedPhotos.Clear();
        _currentPage = 1;
        _totalPages = 0;
        await LoadPhotosPageAsync(1, true);
    }

    public async ValueTask DisposeAsync()
    {
        _dotNetObjectRef?.Dispose();
        
        try
        {
            await JSRuntime.InvokeVoidAsync("IntersectionObserverManager.dispose");
        }
        catch (Exception)
        {
            // Ignore disposal errors
        }
    }
}
